<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Statistiques Loto FDJ - Depuis Nov. 2019</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.7/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <style>
        :root {
            --bg: #0f1117;
            --card: #1a1d29;
            --border: #2a2d3a;
            --text: #e4e4e7;
            --muted: #9ca3af;
            --accent: #3b82f6;
            --accent2: #8b5cf6;
            --red: #ef4444;
            --green: #22c55e;
            --yellow: #eab308;
            --orange: #f97316;
            --chance: #fbbf24;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
        }

        header {
            background: linear-gradient(135deg, #1e3a5f, #2d1b69);
            padding: 2rem;
            text-align: center;
            border-bottom: 2px solid var(--accent);
        }

        header h1 {
            font-size: 2rem;
            background: linear-gradient(90deg, #60a5fa, #a78bfa);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        header p {
            color: var(--muted);
            margin-top: 0.5rem;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 1.5rem;
        }

        .stats-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .stat-card {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1.2rem;
            text-align: center;
        }

        .stat-card .value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--accent);
        }

        .stat-card .label {
            color: var(--muted);
            font-size: 0.85rem;
        }

        nav.tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            border-bottom: 2px solid var(--border);
            padding-bottom: 0.5rem;
        }

        nav.tabs button {
            background: transparent;
            border: none;
            color: var(--muted);
            padding: 0.6rem 1.2rem;
            cursor: pointer;
            border-radius: 8px 8px 0 0;
            font-size: 0.95rem;
            transition: all 0.2s;
        }

        nav.tabs button:hover { color: var(--text); background: var(--card); }
        nav.tabs button.active {
            color: var(--accent);
            background: var(--card);
            border-bottom: 2px solid var(--accent);
        }

        .tab-content { display: none; }
        .tab-content.active { display: block; }

        .retro-table { width: 100%; border-collapse: collapse; margin-top: 1rem; }
        .retro-table th, .retro-table td { padding: 0.6rem 0.8rem; text-align: center; border-bottom: 1px solid var(--border); font-size: 0.85rem; }
        .retro-table th { background: var(--card); color: var(--accent); font-weight: 600; position: sticky; top: 0; }
        .retro-table tr:hover { background: rgba(59,130,246,0.08); }
        .retro-table .match { color: var(--green); font-weight: 700; }
        .retro-table .no-match { color: var(--muted); }
        .retro-badge { display: inline-block; padding: 2px 8px; border-radius: 10px; font-size: 0.75rem; font-weight: 600; }
        .retro-badge.good { background: rgba(34,197,94,0.2); color: var(--green); }
        .retro-badge.great { background: rgba(59,130,246,0.2); color: var(--accent); }
        .retro-badge.amazing { background: rgba(168,85,247,0.2); color: #a855f7; }
        .retro-mini-ball { display: inline-flex; align-items: center; justify-content: center; width: 28px; height: 28px; border-radius: 50%; font-size: 0.75rem; font-weight: 700; margin: 1px; }
        .retro-mini-ball.hit { background: var(--green); color: #fff; }
        .retro-mini-ball.miss { background: var(--border); color: var(--muted); }

        .chart-container {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .chart-container h3 {
            margin-bottom: 1rem;
            color: var(--text);
            font-size: 1.1rem;
        }

        .chart-container canvas {
            max-height: 450px;
        }

        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
        }

        @media (max-width: 768px) {
            .grid-2 { grid-template-columns: 1fr; }
        }

        .number-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(55px, 1fr));
            gap: 8px;
            margin-top: 1rem;
        }

        .number-cell {
            aspect-ratio: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            font-weight: 700;
            font-size: 1rem;
            position: relative;
            cursor: pointer;
            transition: transform 0.15s;
        }

        .number-cell:hover { transform: scale(1.15); }

        .number-cell .count {
            font-size: 0.6rem;
            color: rgba(255,255,255,0.8);
            margin-top: 1px;
        }

        .pairs-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
        }

        .pairs-table th, .pairs-table td {
            padding: 0.6rem 1rem;
            text-align: center;
            border-bottom: 1px solid var(--border);
        }

        .pairs-table th {
            color: var(--muted);
            font-size: 0.8rem;
            text-transform: uppercase;
        }

        .pairs-table tr:hover { background: rgba(59, 130, 246, 0.1); }

        .bar-inline {
            height: 8px;
            border-radius: 4px;
            background: var(--accent);
            display: inline-block;
            vertical-align: middle;
            margin-left: 8px;
        }

        .filter-bar {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            align-items: center;
            margin-bottom: 1rem;
            padding: 1rem;
            background: var(--card);
            border-radius: 12px;
            border: 1px solid var(--border);
        }

        .filter-bar label {
            color: var(--muted);
            font-size: 0.85rem;
        }

        .filter-bar select, .filter-bar input {
            background: var(--bg);
            color: var(--text);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 0.4rem 0.8rem;
            font-size: 0.9rem;
        }

        .legend-item {
            display: inline-flex;
            align-items: center;
            gap: 0.3rem;
            margin-right: 1rem;
            font-size: 0.8rem;
            color: var(--muted);
        }

        .legend-dot {
            width: 12px; height: 12px; border-radius: 50%;
        }

        .retard-highlight {
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4); }
            50% { box-shadow: 0 0 0 8px rgba(239, 68, 68, 0); }
        }

        .suggestion-box {
            background: linear-gradient(135deg, #1e3a5f, #2d1b69);
            border: 1px solid var(--accent);
            border-radius: 12px;
            padding: 1.5rem;
            margin-top: 1rem;
        }

        .suggestion-box h4 {
            color: var(--chance);
            margin-bottom: 0.5rem;
        }

        .suggestion-numbers {
            display: flex;
            gap: 0.8rem;
            flex-wrap: wrap;
            margin-top: 0.5rem;
        }

        .suggestion-numbers .ball {
            width: 48px; height: 48px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 1.2rem;
            background: linear-gradient(135deg, var(--accent), var(--accent2));
            color: white;
        }

        .suggestion-numbers .ball.chance-ball {
            background: linear-gradient(135deg, var(--chance), var(--orange));
            color: #000;
        }

        .info-text {
            color: var(--muted);
            font-size: 0.85rem;
            font-style: italic;
            margin-top: 0.5rem;
        }

        .heatmap-container {
            overflow-x: auto;
        }

        .heatmap-table {
            border-collapse: collapse;
            width: 100%;
        }

        .heatmap-table td {
            width: 30px;
            height: 30px;
            text-align: center;
            font-size: 0.7rem;
            border: 1px solid var(--border);
            cursor: pointer;
        }

        .heatmap-table th {
            font-size: 0.7rem;
            color: var(--muted);
            padding: 4px;
        }

        footer {
            text-align: center;
            padding: 2rem;
            color: var(--muted);
            font-size: 0.8rem;
            border-top: 1px solid var(--border);
            margin-top: 2rem;
        }

        .last-draw {
            background: linear-gradient(135deg, #0c1829 0%, #1a1145 100%);
            border: 1px solid var(--accent);
            border-radius: 16px;
            padding: 2rem;
            margin-bottom: 2rem;
            text-align: center;
        }

        .last-draw h2 {
            font-size: 1.1rem;
            color: var(--muted);
            margin-bottom: 0.3rem;
        }

        .last-draw .draw-date {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text);
            margin-bottom: 1.2rem;
        }

        .last-draw .draw-balls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .last-draw .draw-balls .big-ball {
            width: 72px;
            height: 72px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 800;
            font-size: 1.8rem;
            color: white;
            background: linear-gradient(145deg, #2563eb, #1d4ed8);
            box-shadow: 0 4px 15px rgba(37, 99, 235, 0.4);
        }

        .last-draw .draw-balls .big-ball.chance {
            background: linear-gradient(145deg, #f59e0b, #d97706);
            color: #000;
            box-shadow: 0 4px 15px rgba(245, 158, 11, 0.4);
        }

        .last-draw .draw-balls .separator {
            font-size: 1.5rem;
            color: var(--muted);
            font-weight: 300;
        }
    </style>
</head>
<body>
    <header>
        <h1>üìä Statistiques Loto FDJ</h1>
        <p>Analyse compl√®te de <span id="totalDraws">-</span> tirages ‚Äî Du <span id="dateRange">-</span></p>
        <p style="font-size:0.75rem; color:var(--muted)">Donn√©es officielles FDJ ‚Ä¢ Depuis le changement de r√®gles de nov. 2019 (5 boules parmi 49 + 1 N¬∞ Chance parmi 10)</p>
        <p id="updateStatus" style="font-size:0.75rem; color:var(--chance); margin-top:0.3rem;">Chargement...</p>
    </header>

    <div class="container">
        <!-- Last Draw -->
        <div class="last-draw" id="lastDrawSection" style="display:none">
            <h2>üé± Dernier tirage</h2>
            <div class="draw-date" id="lastDrawDate">-</div>
            <div class="draw-balls" id="lastDrawBalls"></div>
        </div>

        <!-- Summary Stats -->
        <div class="stats-summary">
            <div class="stat-card">
                <div class="value" id="statTotal">-</div>
                <div class="label">Tirages analys√©s</div>
            </div>
            <div class="stat-card">
                <div class="value" id="statMostCommon">-</div>
                <div class="label">Boule la + fr√©quente</div>
            </div>
            <div class="stat-card">
                <div class="value" id="statLeastCommon">-</div>
                <div class="label">Boule la - fr√©quente</div>
            </div>
            <div class="stat-card">
                <div class="value" id="statMaxRetard">-</div>
                <div class="label">Plus grand retard actuel</div>
            </div>
            <div class="stat-card">
                <div class="value" id="statChance">-</div>
                <div class="label">N¬∞ Chance le + fr√©quent</div>
            </div>
        </div>

        <!-- Tabs -->
        <nav class="tabs" id="mainTabs">
            <button class="active" data-tab="freq">Fr√©quences</button>
            <button data-tab="retard">Retards</button>
            <button data-tab="chance">N¬∞ Chance</button>
            <button data-tab="pairs">Paires & Triplets</button>
            <button data-tab="heatmap">Heatmap Paires</button>
            <button data-tab="evolution">√âvolution</button>
            <button data-tab="repartition">R√©partition</button>
            <button data-tab="suggestions">Suggestions</button>
            <button data-tab="retroanalyse">R√©troanalyse</button>
        </nav>

        <!-- TAB: Fr√©quences -->
        <div class="tab-content active" id="tab-freq">
            <div class="filter-bar">
                <label>P√©riode :</label>
                <select id="filterPeriod">
                    <option value="all">Tous les tirages</option>
                    <option value="365">12 derniers mois</option>
                    <option value="180">6 derniers mois</option>
                    <option value="90">3 derniers mois</option>
                    <option value="50">50 derniers tirages</option>
                    <option value="100">100 derniers tirages</option>
                </select>
                <label>Tri :</label>
                <select id="filterSort">
                    <option value="num">Par num√©ro</option>
                    <option value="asc">Moins fr√©quent ‚Üí Plus fr√©quent</option>
                    <option value="desc">Plus fr√©quent ‚Üí Moins fr√©quent</option>
                </select>
            </div>
            <div class="chart-container">
                <h3>Fr√©quence de sortie de chaque boule (1 √† 49)</h3>
                <canvas id="chartFreq"></canvas>
            </div>
            <div class="chart-container">
                <h3>Boules class√©es de la moins √† la plus tir√©e</h3>
                <div id="numberGrid" class="number-grid"></div>
                <div style="margin-top:1rem">
                    <span class="legend-item"><span class="legend-dot" style="background:#ef4444"></span> Tr√®s rare</span>
                    <span class="legend-item"><span class="legend-dot" style="background:#f97316"></span> Rare</span>
                    <span class="legend-item"><span class="legend-dot" style="background:#eab308"></span> Normal</span>
                    <span class="legend-item"><span class="legend-dot" style="background:#22c55e"></span> Fr√©quent</span>
                    <span class="legend-item"><span class="legend-dot" style="background:#3b82f6"></span> Tr√®s fr√©quent</span>
                </div>
            </div>
        </div>

        <!-- TAB: Retards -->
        <div class="tab-content" id="tab-retard">
            <div class="chart-container">
                <h3>üî¥ Retard actuel ‚Äî Nombre de tirages depuis la derni√®re sortie</h3>
                <p class="info-text">Plus le retard est grand, plus le num√©ro n'est pas sorti depuis longtemps.</p>
                <canvas id="chartRetard"></canvas>
            </div>
            <div class="grid-2">
                <div class="chart-container">
                    <h3>Top 15 ‚Äî Plus grands retards actuels</h3>
                    <canvas id="chartTopRetard"></canvas>
                </div>
                <div class="chart-container">
                    <h3>Retard maximum historique par boule</h3>
                    <canvas id="chartMaxRetard"></canvas>
                </div>
            </div>
        </div>

        <!-- TAB: Chance -->
        <div class="tab-content" id="tab-chance">
            <div class="grid-2">
                <div class="chart-container">
                    <h3>Fr√©quence des num√©ros Chance (1-10)</h3>
                    <canvas id="chartChance"></canvas>
                </div>
                <div class="chart-container">
                    <h3>R√©partition N¬∞ Chance (camembert)</h3>
                    <canvas id="chartChancePie"></canvas>
                </div>
            </div>
            <div class="chart-container">
                <h3>Retard actuel des num√©ros Chance</h3>
                <canvas id="chartChanceRetard"></canvas>
            </div>
        </div>

        <!-- TAB: Paires & Triplets -->
        <div class="tab-content" id="tab-pairs">
            <div class="grid-2">
                <div class="chart-container">
                    <h3>üîª 15 Paires les MOINS fr√©quentes (int√©ressant √† jouer ensemble)</h3>
                    <canvas id="chartLeastPairs"></canvas>
                </div>
                <div class="chart-container">
                    <h3>15 Paires les plus fr√©quentes</h3>
                    <canvas id="chartTopPairs"></canvas>
                </div>
            </div>
            <div class="grid-2">
                <div class="chart-container">
                    <h3>üîª 15 Triplets les MOINS fr√©quents</h3>
                    <canvas id="chartLeastTriplets"></canvas>
                </div>
                <div class="chart-container">
                    <h3>15 Triplets les plus fr√©quents</h3>
                    <canvas id="chartTopTriplets"></canvas>
                </div>
            </div>
        </div>

        <!-- TAB: Heatmap -->
        <div class="tab-content" id="tab-heatmap">
            <div class="chart-container">
                <h3>Heatmap des paires ‚Äî Combien de fois chaque paire est sortie ensemble</h3>
                <p class="info-text">Croisez ligne et colonne pour voir le nombre de fois que deux boules sont sorties ensemble. Les cases les plus fonc√©es indiquent les paires les plus rares.</p>
                <div class="heatmap-container" id="heatmapDiv"></div>
            </div>
        </div>

        <!-- TAB: √âvolution -->
        <div class="tab-content" id="tab-evolution">
            <div class="filter-bar">
                <label>Num√©ro √† suivre :</label>
                <select id="evoNumber"></select>
            </div>
            <div class="chart-container">
                <h3>√âvolution de la fr√©quence cumul√©e</h3>
                <canvas id="chartEvolution"></canvas>
            </div>
            <div class="chart-container">
                <h3>√âcart entre les sorties (nombre de tirages entre chaque apparition)</h3>
                <canvas id="chartGaps"></canvas>
            </div>
        </div>

        <!-- TAB: R√©partition -->
        <div class="tab-content" id="tab-repartition">
            <div class="grid-2">
                <div class="chart-container">
                    <h3>R√©partition par dizaine</h3>
                    <canvas id="chartDecades"></canvas>
                </div>
                <div class="chart-container">
                    <h3>Pair vs Impair dans les tirages</h3>
                    <canvas id="chartParite"></canvas>
                </div>
            </div>
            <div class="grid-2">
                <div class="chart-container">
                    <h3>Somme des 5 boules ‚Äî Distribution</h3>
                    <canvas id="chartSomme"></canvas>
                </div>
                <div class="chart-container">
                    <h3>√âcart (max - min) des 5 boules ‚Äî Distribution</h3>
                    <canvas id="chartEcart"></canvas>
                </div>
            </div>
            <div class="chart-container">
                <h3>Fr√©quence par jour de tirage</h3>
                <canvas id="chartJours"></canvas>
            </div>
        </div>

        <!-- TAB: Suggestions -->
        <div class="tab-content" id="tab-suggestions">
            <div class="chart-container">
                <h3>üí° Num√©ros "froids" ‚Äî Les moins sortis r√©cemment</h3>
                <p class="info-text">Bas√© sur les num√©ros avec le plus grand retard ET la plus faible fr√©quence. Ce n'est pas une pr√©diction ‚Äî le Loto reste un jeu de hasard pur.</p>
                <div class="suggestion-box" id="coldSuggestion"></div>
            </div>
            <div class="chart-container">
                <h3>üßä Num√©ros "glac√©s" ‚Äî Statistiquement sous-repr√©sent√©s</h3>
                <p class="info-text">Num√©ros qui sont sortis significativement moins que la moyenne attendue.</p>
                <div class="suggestion-box" id="frozenSuggestion"></div>
            </div>
            <div class="chart-container">
                <h3>üéØ Combinaison bas√©e sur les retards + faible fr√©quence</h3>
                <p class="info-text">Une grille compos√©e des 5 num√©ros les plus en retard et du N¬∞ Chance le plus en retard.</p>
                <div class="suggestion-box" id="comboSuggestion"></div>
            </div>
            <div class="chart-container">
                <h3>üé≤ Grilles "Mix √©quilibr√©" ‚Äî 1 froid + 1 chaud + 3 moyens (3 tranches)</h3>
                <p class="info-text">5 combinaisons compos√©es d'un num√©ro parmi les moins sortis (‚ùÑÔ∏è froid), d'un parmi les plus sortis (üî• chaud), et de 3 num√©ros pris dans 3 tranches de fr√©quence : basse-moyenne, moyenne, haute-moyenne.</p>
                <div class="suggestion-box" id="mixSuggestion"></div>
            </div>
            <div class="chart-container">
                <h3>üìä Analyse √©cart √† la moyenne</h3>
                <canvas id="chartDeviation"></canvas>
            </div>
        </div>
        <!-- TAB: R√©troanalyse -->
        <div class="tab-content" id="tab-retroanalyse">
            <div class="chart-container">
                <h3>üî¨ R√©troanalyse des suggestions ‚Äî Validation historique</h3>
                <p class="info-text">Pour chaque tirage (√† partir du 30·µâ), on recalcule ce qu'auraient √©t√© les suggestions en utilisant <strong>uniquement les tirages pass√©s</strong>, puis on compare au r√©sultat r√©el. Cela permet de mesurer la fiabilit√© de chaque strat√©gie.</p>
                <p class="info-text">R√©f√©rence hasard pur : en moyenne <strong>0.51 boules</strong> sur 5 correspondent par pur hasard (5√ó5/49), et <strong>10%</strong> de chance pour le N¬∞ Chance (1/10).</p>
                <div id="retroLoading" style="text-align:center;padding:2rem;color:var(--muted)">‚è≥ Calcul en cours... Analyse de ~960 tirages</div>
                <div id="retroResults" style="display:none">
                    <div class="stats-summary" id="retroSummary"></div>
                </div>
            </div>
            <div id="retroChartsContainer" style="display:none">
                <div class="grid-2">
                    <div class="chart-container">
                        <h3>üìä Moyenne de boules correctes par strat√©gie</h3>
                        <p class="info-text">Nombre moyen de boules correctement pr√©dites sur 5, compar√© au hasard (ligne rouge).</p>
                        <canvas id="chartRetroAvg"></canvas>
                    </div>
                    <div class="chart-container">
                        <h3>üéØ Taux de match du N¬∞ Chance</h3>
                        <p class="info-text">Pourcentage de fois o√π le N¬∞ Chance sugg√©r√© correspondait au tirage r√©el (hasard = 10%).</p>
                        <canvas id="chartRetroChance"></canvas>
                    </div>
                </div>
                <div class="chart-container">
                    <h3>üìà Distribution des correspondances (0 √† 5 boules justes)</h3>
                    <p class="info-text">Pour chaque strat√©gie, combien de fois la suggestion a eu 0, 1, 2, 3, 4 ou 5 boules correctes.</p>
                    <canvas id="chartRetroDistrib"></canvas>
                </div>
                <div class="chart-container">
                    <h3>üìâ √âvolution des correspondances dans le temps (moyenne glissante sur 50 tirages)</h3>
                    <p class="info-text">Observe si une strat√©gie s'am√©liore ou se d√©grade au fil du temps.</p>
                    <canvas id="chartRetroEvo"></canvas>
                </div>
                <div class="chart-container">
                    <h3>üèÜ Meilleurs r√©sultats ‚Äî Tirages avec ‚â• 2 boules correctes</h3>
                    <p class="info-text">Liste des tirages o√π au moins une strat√©gie a trouv√© 2 boules ou plus.</p>
                    <div id="retroBestTable"></div>
                </div>
            </div>
        </div>
    </div>

    <footer>
        <p>Donn√©es officielles FDJ¬Æ ‚Äî 989 tirages de nov. 2019 √† f√©v. 2026</p>
        <p>‚ö†Ô∏è Le Loto est un jeu de hasard. Les statistiques pass√©es n'influencent pas les tirages futurs.</p>
    </footer>

    <script>
    // ========== DATA & GLOBALS ==========
    let allDraws = [];
    let filteredDraws = [];
    const charts = {};

    const FDJ_ZIP_URL = 'https://www.sto.api.fdj.fr/anonymous/service-draw-info/v3/documentations/1a2b3c4d-9876-4562-b3fc-2c963f66afp6';
    const CACHE_KEY = 'loto_draws_cache';
    const CACHE_TS_KEY = 'loto_cache_ts';
    const CACHE_TTL = 6 * 60 * 60 * 1000; // 6h en ms

    // ========== CSV PARSER ==========
    function parseCSV(csvText) {
        const lines = csvText.split('\n').filter(l => l.trim());
        if (lines.length < 2) return [];
        const draws = [];
        // Skip header (first line)
        for (let i = 1; i < lines.length; i++) {
            const cols = lines[i].split(';');
            if (cols.length < 10) continue;
            try {
                const id = cols[0].trim();
                const day = cols[1].trim();
                const date = cols[2].trim();
                const balls = [
                    parseInt(cols[4].trim()),
                    parseInt(cols[5].trim()),
                    parseInt(cols[6].trim()),
                    parseInt(cols[7].trim()),
                    parseInt(cols[8].trim()),
                ].sort((a,b) => a-b);
                const chance = parseInt(cols[9].trim());
                if (balls.some(isNaN) || isNaN(chance)) continue;
                draws.push({ id, day, date, balls, chance });
            } catch(e) { continue; }
        }
        draws.sort((a, b) => {
            const [ad,am,ay] = a.date.split('/');
            const [bd,bm,by] = b.date.split('/');
            return `${ay}${am}${ad}`.localeCompare(`${by}${bm}${bd}`);
        });
        return draws;
    }

    // ========== LOAD DATA ==========
    async function loadData() {
        showStatus('Chargement des donn√©es...');

        // 1) Try cache first
        const cachedTs = localStorage.getItem(CACHE_TS_KEY);
        const cached = localStorage.getItem(CACHE_KEY);
        const cacheValid = cached && cachedTs && (Date.now() - parseInt(cachedTs)) < CACHE_TTL;

        if (cacheValid) {
            try {
                allDraws = JSON.parse(cached);
                filteredDraws = [...allDraws];
                init();
                showStatus(`${allDraws.length} tirages (cache). V√©rification des mises √† jour...`);
            } catch(e) { /* cache corrupted, continue */ }
        }

        // 2) Try to load from bundled JSON as fallback
        if (!allDraws.length) {
            try {
                const resp = await fetch('loto_data.json');
                if (resp.ok) {
                    allDraws = await resp.json();
                    filteredDraws = [...allDraws];
                    init();
                    showStatus(`${allDraws.length} tirages charg√©s (fichier local). Mise √† jour en cours...`);
                }
            } catch(e) { /* no local file, continue */ }
        }

        // 3) Try to fetch fresh data from FDJ
        try {
            showStatus(allDraws.length ? `${allDraws.length} tirages. V√©rification FDJ...` : 'T√©l√©chargement depuis FDJ...');
            const resp = await fetch(FDJ_ZIP_URL);
            if (!resp.ok) throw new Error(`HTTP ${resp.status}`);

            const blob = await resp.blob();
            const zip = await JSZip.loadAsync(blob);

            // Find CSV file inside ZIP
            let csvText = null;
            for (const filename of Object.keys(zip.files)) {
                if (filename.endsWith('.csv')) {
                    csvText = await zip.files[filename].async('text');
                    break;
                }
            }

            if (csvText) {
                const freshDraws = parseCSV(csvText);
                if (freshDraws.length > 0) {
                    const oldCount = allDraws.length;
                    allDraws = freshDraws;
                    filteredDraws = [...allDraws];

                    // Cache the result
                    try {
                        localStorage.setItem(CACHE_KEY, JSON.stringify(allDraws));
                        localStorage.setItem(CACHE_TS_KEY, Date.now().toString());
                    } catch(e) { /* localStorage full */ }

                    init();
                    const diff = allDraws.length - oldCount;
                    if (diff > 0 && oldCount > 0) {
                        showStatus(`‚úÖ Mis √† jour ! ${allDraws.length} tirages (+${diff} nouveaux)`);
                    } else {
                        showStatus(`‚úÖ ${allDraws.length} tirages ‚Äî Donn√©es √† jour`);
                    }
                }
            }
        } catch(e) {
            console.warn('FDJ fetch failed:', e);
            if (allDraws.length) {
                showStatus(`‚ö†Ô∏è ${allDraws.length} tirages (derni√®re mise √† jour locale). La FDJ n'est pas accessible actuellement.`);
            } else {
                showStatus('‚ùå Impossible de charger les donn√©es. Rechargez la page.');
            }
        }
    }

    function showStatus(msg) {
        const el = document.getElementById('updateStatus');
        if (el) el.textContent = msg;
    }

    loadData();

    // ========== LAST DRAW DISPLAY ==========
    function renderLastDraw() {
        if (!allDraws.length) return;
        const last = allDraws[allDraws.length - 1];
        const dayLabel = last.day.charAt(0).toUpperCase() + last.day.slice(1).toLowerCase();
        document.getElementById('lastDrawDate').textContent = `${dayLabel} ${last.date}`;
        const ballsHTML = last.balls.map(b => `<div class="big-ball">${b}</div>`).join('')
            + '<span class="separator">+</span>'
            + `<div class="big-ball chance">${last.chance}</div>`;
        document.getElementById('lastDrawBalls').innerHTML = ballsHTML;
        document.getElementById('lastDrawSection').style.display = '';
    }

    // ========== INIT ==========
    function init() {
        document.getElementById('totalDraws').textContent = allDraws.length;
        document.getElementById('dateRange').textContent =
            `${allDraws[0].date} au ${allDraws[allDraws.length-1].date}`;
        document.getElementById('statTotal').textContent = allDraws.length;

        // Display last draw
        renderLastDraw();

        // Setup tabs
        document.querySelectorAll('#mainTabs button').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('#mainTabs button').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
                btn.classList.add('active');
                document.getElementById('tab-' + btn.dataset.tab).classList.add('active');
                // Lazy-load retroanalysis
                if (btn.dataset.tab === 'retroanalyse' && !retroDone) {
                    setTimeout(() => runRetroAnalysis(), 50);
                }
            });
        });

        // Setup evo number selector
        const evoSel = document.getElementById('evoNumber');
        for (let i = 1; i <= 49; i++) {
            const opt = document.createElement('option');
            opt.value = i; opt.textContent = `Boule ${i}`;
            evoSel.appendChild(opt);
        }
        evoSel.addEventListener('change', () => renderEvolution());

        // Setup filters
        document.getElementById('filterPeriod').addEventListener('change', () => updateFilter());
        document.getElementById('filterSort').addEventListener('change', () => renderFrequency());

        updateFilter();
    }

    function updateFilter() {
        const period = document.getElementById('filterPeriod').value;
        if (period === 'all') {
            filteredDraws = [...allDraws];
        } else {
            const n = parseInt(period);
            if (n <= 100) {
                // Use last N draws
                filteredDraws = allDraws.slice(-n);
            } else {
                // Use last N days
                const cutoff = new Date();
                cutoff.setDate(cutoff.getDate() - n);
                filteredDraws = allDraws.filter(d => {
                    const [dd, mm, yy] = d.date.split('/');
                    return new Date(yy, mm-1, dd) >= cutoff;
                });
            }
        }
        renderAll();
    }

    // ========== COMPUTE STATS ==========
    function computeFrequencies(draws) {
        const freq = {};
        for (let i = 1; i <= 49; i++) freq[i] = 0;
        draws.forEach(d => d.balls.forEach(b => freq[b]++));
        return freq;
    }

    function computeChanceFreq(draws) {
        const freq = {};
        for (let i = 1; i <= 10; i++) freq[i] = 0;
        draws.forEach(d => freq[d.chance]++);
        return freq;
    }

    function computeRetards(draws) {
        const retard = {};
        for (let i = 1; i <= 49; i++) retard[i] = draws.length; // default: never appeared
        for (let idx = draws.length - 1; idx >= 0; idx--) {
            draws[idx].balls.forEach(b => {
                if (retard[b] === draws.length) {
                    retard[b] = draws.length - 1 - idx;
                }
            });
        }
        // Actually compute properly: retard = number of draws since last appearance
        const ret = {};
        for (let i = 1; i <= 49; i++) ret[i] = draws.length;
        for (let idx = draws.length - 1; idx >= 0; idx--) {
            draws[idx].balls.forEach(b => {
                const r = draws.length - 1 - idx;
                if (r < ret[b]) ret[b] = r;
            });
        }
        return ret;
    }

    function computeChanceRetards(draws) {
        const ret = {};
        for (let i = 1; i <= 10; i++) ret[i] = draws.length;
        for (let idx = draws.length - 1; idx >= 0; idx--) {
            const r = draws.length - 1 - idx;
            if (r < ret[draws[idx].chance]) ret[draws[idx].chance] = r;
        }
        return ret;
    }

    function computeMaxRetards(draws) {
        const maxRet = {};
        const lastSeen = {};
        for (let i = 1; i <= 49; i++) { maxRet[i] = 0; lastSeen[i] = -1; }
        draws.forEach((d, idx) => {
            d.balls.forEach(b => {
                if (lastSeen[b] >= 0) {
                    const gap = idx - lastSeen[b];
                    if (gap > maxRet[b]) maxRet[b] = gap;
                }
                lastSeen[b] = idx;
            });
            // Also check current retard at end
        });
        // Check final retard
        for (let i = 1; i <= 49; i++) {
            const finalRetard = draws.length - 1 - lastSeen[i];
            if (lastSeen[i] === -1) maxRet[i] = draws.length;
            else if (finalRetard > maxRet[i]) maxRet[i] = finalRetard;
        }
        return maxRet;
    }

    function computePairs(draws) {
        const pairs = {};
        draws.forEach(d => {
            for (let i = 0; i < d.balls.length; i++) {
                for (let j = i + 1; j < d.balls.length; j++) {
                    const key = `${d.balls[i]}-${d.balls[j]}`;
                    pairs[key] = (pairs[key] || 0) + 1;
                }
            }
        });
        return pairs;
    }

    function computeTriplets(draws) {
        const trips = {};
        draws.forEach(d => {
            for (let i = 0; i < d.balls.length; i++) {
                for (let j = i + 1; j < d.balls.length; j++) {
                    for (let k = j + 1; k < d.balls.length; k++) {
                        const key = `${d.balls[i]}-${d.balls[j]}-${d.balls[k]}`;
                        trips[key] = (trips[key] || 0) + 1;
                    }
                }
            }
        });
        return trips;
    }

    // ========== COLOR HELPERS ==========
    function freqColor(val, min, max) {
        const ratio = (val - min) / (max - min || 1);
        if (ratio < 0.2) return '#ef4444';
        if (ratio < 0.4) return '#f97316';
        if (ratio < 0.6) return '#eab308';
        if (ratio < 0.8) return '#22c55e';
        return '#3b82f6';
    }

    function heatColor(val, maxVal) {
        if (val === 0) return '#1a1d29';
        const ratio = val / maxVal;
        const r = Math.round(30 + ratio * 100);
        const g = Math.round(30 + ratio * 100);
        const b = Math.round(60 + ratio * 196);
        return `rgb(${r},${g},${b})`;
    }

    // ========== CHART HELPERS ==========
    function makeChart(id, config) {
        if (charts[id]) charts[id].destroy();
        charts[id] = new Chart(document.getElementById(id), config);
        return charts[id];
    }

    // ========== RENDER ALL ==========
    function renderAll() {
        const freq = computeFrequencies(filteredDraws);
        const retards = computeRetards(filteredDraws);

        // Summary stats
        const sortedByFreq = Object.entries(freq).sort((a,b) => b[1] - a[1]);
        const sortedByRetard = Object.entries(retards).sort((a,b) => b[1] - a[1]);
        const chanceFreq = computeChanceFreq(filteredDraws);
        const sortedChance = Object.entries(chanceFreq).sort((a,b) => b[1] - a[1]);

        document.getElementById('statMostCommon').textContent = `N¬∞${sortedByFreq[0][0]} (${sortedByFreq[0][1]}√ó)`;
        document.getElementById('statLeastCommon').textContent = `N¬∞${sortedByFreq[sortedByFreq.length-1][0]} (${sortedByFreq[sortedByFreq.length-1][1]}√ó)`;
        document.getElementById('statMaxRetard').textContent = `N¬∞${sortedByRetard[0][0]} (${sortedByRetard[0][1]} tirages)`;
        document.getElementById('statChance').textContent = `N¬∞${sortedChance[0][0]} (${sortedChance[0][1]}√ó)`;

        renderFrequency();
        renderRetards();
        renderChance();
        renderPairs();
        renderHeatmap();
        renderEvolution();
        renderRepartition();
        renderSuggestions();
    }

    // ========== RENDER: FREQUENCY ==========
    function renderFrequency() {
        const freq = computeFrequencies(filteredDraws);
        const sortType = document.getElementById('filterSort').value;

        let labels, values;
        if (sortType === 'num') {
            labels = Array.from({length:49}, (_,i) => i+1);
            values = labels.map(l => freq[l]);
        } else if (sortType === 'asc') {
            const sorted = Object.entries(freq).sort((a,b) => a[1] - b[1]);
            labels = sorted.map(s => s[0]);
            values = sorted.map(s => s[1]);
        } else {
            const sorted = Object.entries(freq).sort((a,b) => b[1] - a[1]);
            labels = sorted.map(s => s[0]);
            values = sorted.map(s => s[1]);
        }

        const minV = Math.min(...values);
        const maxV = Math.max(...values);
        const avg = values.reduce((a,b)=>a+b,0) / values.length;

        makeChart('chartFreq', {
            type: 'bar',
            data: {
                labels: labels.map(l => `N¬∞${l}`),
                datasets: [{
                    label: 'Nombre de sorties',
                    data: values,
                    backgroundColor: values.map(v => freqColor(v, minV, maxV)),
                    borderRadius: 4,
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            afterLabel: (ctx) => {
                                const pct = ((ctx.parsed.y / filteredDraws.length) * 100).toFixed(1);
                                return `${pct}% des tirages\nMoyenne: ${avg.toFixed(1)}`;
                            }
                        }
                    },
                    annotation: undefined
                },
                scales: {
                    y: {
                        grid: { color: 'rgba(255,255,255,0.05)' },
                        ticks: { color: '#9ca3af' }
                    },
                    x: {
                        grid: { display: false },
                        ticks: { color: '#9ca3af', maxRotation: 90, font: { size: 10 } }
                    }
                }
            }
        });

        // Number grid
        const grid = document.getElementById('numberGrid');
        grid.innerHTML = '';
        const sorted = Object.entries(freq).sort((a,b) => a[1] - b[1]);
        sorted.forEach(([num, count]) => {
            const cell = document.createElement('div');
            cell.className = 'number-cell';
            cell.style.background = freqColor(count, minV, maxV);
            cell.style.color = 'white';
            cell.innerHTML = `${num}<span class="count">${count}√ó</span>`;
            cell.title = `Boule ${num}: ${count} sorties (${((count/filteredDraws.length)*100).toFixed(1)}%)`;
            grid.appendChild(cell);
        });
    }

    // ========== RENDER: RETARDS ==========
    function renderRetards() {
        const retards = computeRetards(filteredDraws);
        const maxRetards = computeMaxRetards(filteredDraws);

        const labels = Array.from({length:49}, (_,i) => `N¬∞${i+1}`);
        const values = Array.from({length:49}, (_,i) => retards[i+1]);
        const maxV = Math.max(...values);

        makeChart('chartRetard', {
            type: 'bar',
            data: {
                labels,
                datasets: [{
                    label: 'Retard actuel',
                    data: values,
                    backgroundColor: values.map(v => {
                        const ratio = v / maxV;
                        if (ratio > 0.8) return '#ef4444';
                        if (ratio > 0.6) return '#f97316';
                        if (ratio > 0.4) return '#eab308';
                        return '#22c55e';
                    }),
                    borderRadius: 4,
                }]
            },
            options: {
                responsive: true,
                plugins: { legend: { display: false } },
                scales: {
                    y: { grid: { color: 'rgba(255,255,255,0.05)' }, ticks: { color: '#9ca3af' } },
                    x: { grid: { display: false }, ticks: { color: '#9ca3af', maxRotation: 90, font: { size: 10 } } }
                }
            }
        });

        // Top 15 retards
        const top15 = Object.entries(retards).sort((a,b) => b[1]-a[1]).slice(0, 15);
        makeChart('chartTopRetard', {
            type: 'bar',
            data: {
                labels: top15.map(t => `N¬∞${t[0]}`),
                datasets: [{
                    label: 'Retard',
                    data: top15.map(t => t[1]),
                    backgroundColor: '#ef4444',
                    borderRadius: 4,
                }]
            },
            options: {
                indexAxis: 'y',
                responsive: true,
                plugins: { legend: { display: false } },
                scales: {
                    x: { grid: { color: 'rgba(255,255,255,0.05)' }, ticks: { color: '#9ca3af' } },
                    y: { grid: { display: false }, ticks: { color: '#e4e4e7' } }
                }
            }
        });

        // Max retards historiques
        const maxLabels = Array.from({length:49}, (_,i) => `N¬∞${i+1}`);
        const maxValues = Array.from({length:49}, (_,i) => maxRetards[i+1]);
        makeChart('chartMaxRetard', {
            type: 'bar',
            data: {
                labels: maxLabels,
                datasets: [{
                    label: 'Retard max historique',
                    data: maxValues,
                    backgroundColor: '#8b5cf6',
                    borderRadius: 4,
                }]
            },
            options: {
                responsive: true,
                plugins: { legend: { display: false } },
                scales: {
                    y: { grid: { color: 'rgba(255,255,255,0.05)' }, ticks: { color: '#9ca3af' } },
                    x: { grid: { display: false }, ticks: { color: '#9ca3af', maxRotation: 90, font: { size: 9 } } }
                }
            }
        });
    }

    // ========== RENDER: CHANCE ==========
    function renderChance() {
        const chanceFreq = computeChanceFreq(filteredDraws);
        const chanceRetards = computeChanceRetards(filteredDraws);

        const labels = Array.from({length:10}, (_,i) => `N¬∞${i+1}`);
        const values = Array.from({length:10}, (_,i) => chanceFreq[i+1]);
        const colors = ['#ef4444','#f97316','#eab308','#22c55e','#3b82f6','#8b5cf6','#ec4899','#14b8a6','#f59e0b','#6366f1'];

        makeChart('chartChance', {
            type: 'bar',
            data: {
                labels,
                datasets: [{
                    label: 'Sorties',
                    data: values,
                    backgroundColor: colors,
                    borderRadius: 6,
                }]
            },
            options: {
                responsive: true,
                plugins: { legend: { display: false } },
                scales: {
                    y: { grid: { color: 'rgba(255,255,255,0.05)' }, ticks: { color: '#9ca3af' } },
                    x: { grid: { display: false }, ticks: { color: '#9ca3af' } }
                }
            }
        });

        makeChart('chartChancePie', {
            type: 'doughnut',
            data: {
                labels,
                datasets: [{
                    data: values,
                    backgroundColor: colors,
                    borderColor: '#1a1d29',
                    borderWidth: 2,
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: { position: 'right', labels: { color: '#9ca3af' } },
                    tooltip: {
                        callbacks: {
                            label: (ctx) => `${ctx.label}: ${ctx.parsed} (${((ctx.parsed/filteredDraws.length)*100).toFixed(1)}%)`
                        }
                    }
                }
            }
        });

        const retLabels = Array.from({length:10}, (_,i) => `N¬∞${i+1}`);
        const retValues = Array.from({length:10}, (_,i) => chanceRetards[i+1]);
        makeChart('chartChanceRetard', {
            type: 'bar',
            data: {
                labels: retLabels,
                datasets: [{
                    label: 'Retard actuel',
                    data: retValues,
                    backgroundColor: retValues.map(v => v > 15 ? '#ef4444' : v > 10 ? '#f97316' : '#22c55e'),
                    borderRadius: 6,
                }]
            },
            options: {
                responsive: true,
                plugins: { legend: { display: false } },
                scales: {
                    y: { grid: { color: 'rgba(255,255,255,0.05)' }, ticks: { color: '#9ca3af' } },
                    x: { grid: { display: false }, ticks: { color: '#9ca3af' } }
                }
            }
        });
    }

    // ========== RENDER: PAIRS ==========
    function renderPairs() {
        const pairs = computePairs(filteredDraws);
        const triplets = computeTriplets(filteredDraws);

        // Top 15 pairs (most)
        const topPairs = Object.entries(pairs).sort((a,b) => b[1]-a[1]).slice(0, 15);
        makeChart('chartTopPairs', {
            type: 'bar',
            data: {
                labels: topPairs.map(p => p[0]),
                datasets: [{
                    label: 'Sorties ensemble',
                    data: topPairs.map(p => p[1]),
                    backgroundColor: '#3b82f6',
                    borderRadius: 4,
                }]
            },
            options: {
                indexAxis: 'y',
                responsive: true,
                plugins: { legend: { display: false } },
                scales: {
                    x: { grid: { color: 'rgba(255,255,255,0.05)' }, ticks: { color: '#9ca3af' } },
                    y: { grid: { display: false }, ticks: { color: '#e4e4e7', font: { size: 11 } } }
                }
            }
        });

        // Top 15 least frequent pairs (that appeared at least once)
        const leastPairs = Object.entries(pairs).sort((a,b) => a[1]-b[1]).slice(0, 15);
        makeChart('chartLeastPairs', {
            type: 'bar',
            data: {
                labels: leastPairs.map(p => p[0]),
                datasets: [{
                    label: 'Sorties ensemble',
                    data: leastPairs.map(p => p[1]),
                    backgroundColor: '#ef4444',
                    borderRadius: 4,
                }]
            },
            options: {
                indexAxis: 'y',
                responsive: true,
                plugins: { legend: { display: false } },
                scales: {
                    x: { grid: { color: 'rgba(255,255,255,0.05)' }, ticks: { color: '#9ca3af' } },
                    y: { grid: { display: false }, ticks: { color: '#e4e4e7', font: { size: 11 } } }
                }
            }
        });

        // Triplets
        const topTrips = Object.entries(triplets).sort((a,b) => b[1]-a[1]).slice(0, 15);
        makeChart('chartTopTriplets', {
            type: 'bar',
            data: {
                labels: topTrips.map(p => p[0]),
                datasets: [{
                    label: 'Sorties ensemble',
                    data: topTrips.map(p => p[1]),
                    backgroundColor: '#8b5cf6',
                    borderRadius: 4,
                }]
            },
            options: {
                indexAxis: 'y',
                responsive: true,
                plugins: { legend: { display: false } },
                scales: {
                    x: { grid: { color: 'rgba(255,255,255,0.05)' }, ticks: { color: '#9ca3af' } },
                    y: { grid: { display: false }, ticks: { color: '#e4e4e7', font: { size: 10 } } }
                }
            }
        });

        const leastTrips = Object.entries(triplets).sort((a,b) => a[1]-b[1]).slice(0, 15);
        makeChart('chartLeastTriplets', {
            type: 'bar',
            data: {
                labels: leastTrips.map(p => p[0]),
                datasets: [{
                    label: 'Sorties ensemble',
                    data: leastTrips.map(p => p[1]),
                    backgroundColor: '#ef4444',
                    borderRadius: 4,
                }]
            },
            options: {
                indexAxis: 'y',
                responsive: true,
                plugins: { legend: { display: false } },
                scales: {
                    x: { grid: { color: 'rgba(255,255,255,0.05)' }, ticks: { color: '#9ca3af' } },
                    y: { grid: { display: false }, ticks: { color: '#e4e4e7', font: { size: 10 } } }
                }
            }
        });
    }

    // ========== RENDER: HEATMAP ==========
    function renderHeatmap() {
        const pairs = computePairs(filteredDraws);
        const maxPairVal = Math.max(...Object.values(pairs));

        let html = '<table class="heatmap-table"><tr><th></th>';
        for (let i = 1; i <= 49; i++) html += `<th>${i}</th>`;
        html += '</tr>';

        for (let i = 1; i <= 49; i++) {
            html += `<tr><th>${i}</th>`;
            for (let j = 1; j <= 49; j++) {
                if (i === j) {
                    html += '<td style="background:#2a2d3a">‚Äî</td>';
                } else {
                    const key = i < j ? `${i}-${j}` : `${j}-${i}`;
                    const val = pairs[key] || 0;
                    html += `<td style="background:${heatColor(val, maxPairVal)};color:${val > maxPairVal*0.5 ? '#fff' : '#666'}" title="Paire ${key}: ${val}√ó">${val}</td>`;
                }
            }
            html += '</tr>';
        }
        html += '</table>';
        document.getElementById('heatmapDiv').innerHTML = html;
    }

    // ========== RENDER: EVOLUTION ==========
    function renderEvolution() {
        const num = parseInt(document.getElementById('evoNumber').value) || 1;

        // Cumulative frequency
        const cumFreq = [];
        let count = 0;
        const gaps = [];
        let lastIdx = -1;

        filteredDraws.forEach((d, idx) => {
            if (d.balls.includes(num)) {
                count++;
                if (lastIdx >= 0) gaps.push(idx - lastIdx);
                lastIdx = idx;
            }
            cumFreq.push(count);
        });

        const expectedLine = filteredDraws.map((_, idx) => (idx + 1) * 5 / 49);

        makeChart('chartEvolution', {
            type: 'line',
            data: {
                labels: filteredDraws.map(d => d.date),
                datasets: [
                    {
                        label: `Fr√©quence cumul√©e N¬∞${num}`,
                        data: cumFreq,
                        borderColor: '#3b82f6',
                        backgroundColor: 'rgba(59,130,246,0.1)',
                        fill: true,
                        tension: 0.2,
                        pointRadius: 0,
                    },
                    {
                        label: 'Fr√©quence attendue (th√©orique)',
                        data: expectedLine,
                        borderColor: '#ef4444',
                        borderDash: [5,5],
                        fill: false,
                        pointRadius: 0,
                    }
                ]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: { labels: { color: '#9ca3af' } }
                },
                scales: {
                    y: { grid: { color: 'rgba(255,255,255,0.05)' }, ticks: { color: '#9ca3af' } },
                    x: {
                        grid: { display: false },
                        ticks: { color: '#9ca3af', maxTicksLimit: 20, maxRotation: 45 }
                    }
                }
            }
        });

        // Gaps
        makeChart('chartGaps', {
            type: 'bar',
            data: {
                labels: gaps.map((_, i) => `√âcart ${i+1}`),
                datasets: [{
                    label: `Tirages entre 2 sorties du N¬∞${num}`,
                    data: gaps,
                    backgroundColor: gaps.map(g => g > 20 ? '#ef4444' : g > 10 ? '#f97316' : '#22c55e'),
                    borderRadius: 3,
                }]
            },
            options: {
                responsive: true,
                plugins: { legend: { display: false } },
                scales: {
                    y: { grid: { color: 'rgba(255,255,255,0.05)' }, ticks: { color: '#9ca3af' } },
                    x: { grid: { display: false }, ticks: { display: false } }
                }
            }
        });
    }

    // ========== RENDER: REPARTITION ==========
    function renderRepartition() {
        // By decade
        const decades = { '1-9': 0, '10-19': 0, '20-29': 0, '30-39': 0, '40-49': 0 };
        filteredDraws.forEach(d => {
            d.balls.forEach(b => {
                if (b <= 9) decades['1-9']++;
                else if (b <= 19) decades['10-19']++;
                else if (b <= 29) decades['20-29']++;
                else if (b <= 39) decades['30-39']++;
                else decades['40-49']++;
            });
        });

        makeChart('chartDecades', {
            type: 'bar',
            data: {
                labels: Object.keys(decades),
                datasets: [{
                    label: 'Sorties',
                    data: Object.values(decades),
                    backgroundColor: ['#ef4444', '#f97316', '#eab308', '#22c55e', '#3b82f6'],
                    borderRadius: 6,
                }]
            },
            options: {
                responsive: true,
                plugins: { legend: { display: false } },
                scales: {
                    y: { grid: { color: 'rgba(255,255,255,0.05)' }, ticks: { color: '#9ca3af' } },
                    x: { grid: { display: false }, ticks: { color: '#9ca3af' } }
                }
            }
        });

        // Parity
        const parityDist = {};
        filteredDraws.forEach(d => {
            const odd = d.balls.filter(b => b % 2 !== 0).length;
            const key = `${odd} impairs / ${5-odd} pairs`;
            parityDist[key] = (parityDist[key] || 0) + 1;
        });
        const parityLabels = Object.keys(parityDist).sort();
        makeChart('chartParite', {
            type: 'bar',
            data: {
                labels: parityLabels,
                datasets: [{
                    label: 'Nombre de tirages',
                    data: parityLabels.map(l => parityDist[l]),
                    backgroundColor: '#8b5cf6',
                    borderRadius: 6,
                }]
            },
            options: {
                responsive: true,
                plugins: { legend: { display: false } },
                scales: {
                    y: { grid: { color: 'rgba(255,255,255,0.05)' }, ticks: { color: '#9ca3af' } },
                    x: { grid: { display: false }, ticks: { color: '#9ca3af' } }
                }
            }
        });

        // Sum distribution
        const sums = {};
        filteredDraws.forEach(d => {
            const s = d.balls.reduce((a,b) => a+b, 0);
            const bucket = Math.floor(s / 10) * 10;
            const key = `${bucket}-${bucket+9}`;
            sums[key] = (sums[key] || 0) + 1;
        });
        const sumLabels = Object.keys(sums).sort((a,b) => parseInt(a) - parseInt(b));
        makeChart('chartSomme', {
            type: 'bar',
            data: {
                labels: sumLabels,
                datasets: [{
                    label: 'Nombre de tirages',
                    data: sumLabels.map(l => sums[l]),
                    backgroundColor: '#3b82f6',
                    borderRadius: 4,
                }]
            },
            options: {
                responsive: true,
                plugins: { legend: { display: false } },
                scales: {
                    y: { grid: { color: 'rgba(255,255,255,0.05)' }, ticks: { color: '#9ca3af' } },
                    x: { grid: { display: false }, ticks: { color: '#9ca3af' } }
                }
            }
        });

        // Spread (max - min)
        const spreads = {};
        filteredDraws.forEach(d => {
            const spread = d.balls[d.balls.length-1] - d.balls[0];
            const bucket = Math.floor(spread / 5) * 5;
            const key = `${bucket}-${bucket+4}`;
            spreads[key] = (spreads[key] || 0) + 1;
        });
        const spreadLabels = Object.keys(spreads).sort((a,b) => parseInt(a) - parseInt(b));
        makeChart('chartEcart', {
            type: 'bar',
            data: {
                labels: spreadLabels,
                datasets: [{
                    label: 'Nombre de tirages',
                    data: spreadLabels.map(l => spreads[l]),
                    backgroundColor: '#f97316',
                    borderRadius: 4,
                }]
            },
            options: {
                responsive: true,
                plugins: { legend: { display: false } },
                scales: {
                    y: { grid: { color: 'rgba(255,255,255,0.05)' }, ticks: { color: '#9ca3af' } },
                    x: { grid: { display: false }, ticks: { color: '#9ca3af' } }
                }
            }
        });

        // By day of week
        const days = {};
        filteredDraws.forEach(d => {
            days[d.day] = (days[d.day] || 0) + 1;
        });
        makeChart('chartJours', {
            type: 'bar',
            data: {
                labels: Object.keys(days),
                datasets: [{
                    label: 'Nombre de tirages',
                    data: Object.values(days),
                    backgroundColor: ['#3b82f6', '#22c55e', '#eab308', '#ef4444', '#8b5cf6', '#f97316', '#ec4899'],
                    borderRadius: 6,
                }]
            },
            options: {
                responsive: true,
                plugins: { legend: { display: false } },
                scales: {
                    y: { grid: { color: 'rgba(255,255,255,0.05)' }, ticks: { color: '#9ca3af' } },
                    x: { grid: { display: false }, ticks: { color: '#9ca3af' } }
                }
            }
        });
    }

    // ========== RENDER: SUGGESTIONS ==========
    function renderSuggestions() {
        const freq = computeFrequencies(filteredDraws);
        const retards = computeRetards(filteredDraws);
        const chanceRetards = computeChanceRetards(filteredDraws);
        const chanceFreq = computeChanceFreq(filteredDraws);
        const avgFreq = filteredDraws.length * 5 / 49;

        // Cold numbers: highest retard
        const sortedRetard = Object.entries(retards).sort((a,b) => b[1]-a[1]);
        const coldNumbers = sortedRetard.slice(0, 5).map(e => parseInt(e[0]));
        const coldChance = Object.entries(chanceRetards).sort((a,b) => b[1]-a[1])[0];

        document.getElementById('coldSuggestion').innerHTML = `
            <h4>Les 5 boules avec le plus grand retard + N¬∞ Chance le plus en retard</h4>
            <div class="suggestion-numbers">
                ${coldNumbers.sort((a,b)=>a-b).map(n => `<div class="ball">${n}</div>`).join('')}
                <div class="ball chance-ball">${coldChance[0]}</div>
            </div>
            <p class="info-text">Retards: ${sortedRetard.slice(0,5).map(e => `N¬∞${e[0]}=${e[1]} tirages`).join(', ')} | Chance N¬∞${coldChance[0]}=${coldChance[1]} tirages</p>
        `;

        // Frozen: lowest frequency
        const sortedFreq = Object.entries(freq).sort((a,b) => a[1]-b[1]);
        const frozenNumbers = sortedFreq.slice(0, 5).map(e => parseInt(e[0]));
        const frozenChance = Object.entries(chanceFreq).sort((a,b) => a[1]-b[1])[0];

        document.getElementById('frozenSuggestion').innerHTML = `
            <h4>Les 5 boules les moins souvent tir√©es + N¬∞ Chance le moins tir√©</h4>
            <div class="suggestion-numbers">
                ${frozenNumbers.sort((a,b)=>a-b).map(n => `<div class="ball">${n}</div>`).join('')}
                <div class="ball chance-ball">${frozenChance[0]}</div>
            </div>
            <p class="info-text">Fr√©quences: ${sortedFreq.slice(0,5).map(e => `N¬∞${e[0]}=${e[1]}√ó (moy: ${avgFreq.toFixed(1)})`).join(', ')} | Chance N¬∞${frozenChance[0]}=${frozenChance[1]}√ó</p>
        `;

        // Combo: weighted score (retard * 2 + deficit from average)
        const scores = {};
        for (let i = 1; i <= 49; i++) {
            const deficit = avgFreq - freq[i];
            scores[i] = retards[i] * 2 + Math.max(0, deficit * 3);
        }
        const bestCombo = Object.entries(scores).sort((a,b) => b[1]-a[1]).slice(0, 5).map(e => parseInt(e[0]));
        const bestChance = Object.entries(chanceRetards).sort((a,b) => {
            const cDef = (filteredDraws.length / 10) - chanceFreq[a[0]];
            const dDef = (filteredDraws.length / 10) - chanceFreq[b[0]];
            return (b[1]*2 + Math.max(0,dDef*3)) - (a[1]*2 + Math.max(0,cDef*3));
        })[0];

        document.getElementById('comboSuggestion').innerHTML = `
            <h4>Grille "Score combin√©" (retard √ó 2 + d√©ficit de fr√©quence √ó 3)</h4>
            <div class="suggestion-numbers">
                ${bestCombo.sort((a,b)=>a-b).map(n => `<div class="ball">${n}</div>`).join('')}
                <div class="ball chance-ball">${bestChance[0]}</div>
            </div>
            <p class="info-text">Score = retard_actuel √ó 2 + max(0, (moyenne - fr√©quence) √ó 3). Plus le score est √©lev√©, plus le num√©ro est "en retard" statistiquement.</p>
        `;

        // Mix suggestions: 5 grids with 1 cold + 1 hot + 3 from 3 frequency tiers
        const sortedByFreqAll = Object.entries(freq).sort((a,b) => a[1] - b[1]);
        const totalNums = sortedByFreqAll.length; // 49

        // Split into 5 zones: cold (bottom 20%), low-avg, mid-avg, high-avg, hot (top 20%)
        const coldPool = sortedByFreqAll.slice(0, Math.ceil(totalNums * 0.2)).map(([n]) => parseInt(n));
        const hotPool = sortedByFreqAll.slice(-Math.ceil(totalNums * 0.2)).map(([n]) => parseInt(n));

        // Middle 60% split into 3 tiers of ~20% each
        const middleAll = sortedByFreqAll.slice(Math.ceil(totalNums * 0.2), -Math.ceil(totalNums * 0.2));
        const tierSize = Math.ceil(middleAll.length / 3);
        const tierLow = middleAll.slice(0, tierSize).map(([n]) => parseInt(n));       // basse-moyenne
        const tierMid = middleAll.slice(tierSize, tierSize * 2).map(([n]) => parseInt(n)); // moyenne
        const tierHigh = middleAll.slice(tierSize * 2).map(([n]) => parseInt(n));      // haute-moyenne

        // Chance: sorted by distance to average
        const avgChanceFreq = filteredDraws.length / 10;
        const chanceSortedMix = Object.entries(chanceFreq)
            .map(([n, c]) => ({ num: parseInt(n), diff: Math.abs(c - avgChanceFreq) }))
            .sort((a,b) => a.diff - b.diff);

        // Shuffle helper (Fisher-Yates)
        function shuffle(arr) {
            const a = [...arr];
            for (let i = a.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [a[i], a[j]] = [a[j], a[i]];
            }
            return a;
        }

        // Generate 5 unique grids
        const usedGrids = new Set();
        const mixGrids = [];
        let attempts = 0;
        while (mixGrids.length < 5 && attempts < 200) {
            attempts++;
            const cold = shuffle(coldPool)[0];
            const hot = shuffle(hotPool)[0];
            const low = shuffle(tierLow)[0];
            const mid = shuffle(tierMid)[0];
            const high = shuffle(tierHigh)[0];
            const nums = [cold, low, mid, high, hot].sort((a,b) => a - b);
            const key = nums.join('-');
            if (usedGrids.has(key)) continue;
            // Ensure all 5 are different numbers
            if (new Set(nums).size !== 5) continue;
            usedGrids.add(key);
            const chIdx = mixGrids.length % chanceSortedMix.length;
            mixGrids.push({
                nums,
                cold, hot, low, mid, high,
                chance: chanceSortedMix[chIdx].num
            });
        }

        let mixHTML = '';
        mixGrids.forEach((grid, idx) => {
            mixHTML += `
            <h4>Grille ${idx + 1}</h4>
            <div class="suggestion-numbers">
                ${grid.nums.map(n => {
                    let bg, label, title;
                    if (n === grid.cold) {
                        bg = 'linear-gradient(135deg, #3b82f6, #1d4ed8)'; label = '‚ùÑÔ∏è'; title = `Froid (${freq[n]}√ó)`;
                    } else if (n === grid.hot) {
                        bg = 'linear-gradient(135deg, #ef4444, #dc2626)'; label = 'üî•'; title = `Chaud (${freq[n]}√ó)`;
                    } else if (n === grid.low) {
                        bg = 'linear-gradient(135deg, #6366f1, #4f46e5)'; label = ''; title = `Basse-moy (${freq[n]}√ó)`;
                    } else if (n === grid.mid) {
                        bg = 'linear-gradient(135deg, var(--accent), var(--accent2))'; label = ''; title = `Moyenne (${freq[n]}√ó)`;
                    } else {
                        bg = 'linear-gradient(135deg, #f59e0b, #d97706)'; label = ''; title = `Haute-moy (${freq[n]}√ó)`;
                    }
                    return `<div class="ball" style="background:${bg}" title="${title}">${label}${n}</div>`;
                }).join('')}
                <div class="ball chance-ball">${grid.chance}</div>
            </div>
            <p class="info-text" style="margin-bottom:16px">
                ‚ùÑÔ∏è N¬∞${grid.cold}=${freq[grid.cold]}√ó |
                <span style="color:#818cf8">‚ñ∏</span> N¬∞${grid.low}=${freq[grid.low]}√ó (basse-moy) |
                <span style="color:#f59e0b">‚ñ∏</span> N¬∞${grid.mid}=${freq[grid.mid]}√ó (moy) |
                <span style="color:#fbbf24">‚ñ∏</span> N¬∞${grid.high}=${freq[grid.high]}√ó (haute-moy) |
                üî• N¬∞${grid.hot}=${freq[grid.hot]}√ó |
                Chance: ${grid.chance}
            </p>`;
        });

        mixHTML += `<p class="info-text" style="margin-top:8px">Tranches: froid (&lt;${freq[coldPool[coldPool.length-1]]}√ó) | basse-moy (${freq[tierLow[0]]}‚Äì${freq[tierLow[tierLow.length-1]]}√ó) | moy (${freq[tierMid[0]]}‚Äì${freq[tierMid[tierMid.length-1]]}√ó) | haute-moy (${freq[tierHigh[0]]}‚Äì${freq[tierHigh[tierHigh.length-1]]}√ó) | chaud (&gt;${freq[hotPool[0]]}√ó)</p>`;

        document.getElementById('mixSuggestion').innerHTML = mixHTML;

        // Deviation chart
        const deviations = [];
        const devLabels = [];
        for (let i = 1; i <= 49; i++) {
            devLabels.push(`N¬∞${i}`);
            deviations.push(freq[i] - avgFreq);
        }

        makeChart('chartDeviation', {
            type: 'bar',
            data: {
                labels: devLabels,
                datasets: [{
                    label: '√âcart √† la moyenne',
                    data: deviations,
                    backgroundColor: deviations.map(d => d < 0 ? '#ef4444' : '#22c55e'),
                    borderRadius: 4,
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            afterLabel: (ctx) => {
                                const num = ctx.dataIndex + 1;
                                return `Sorties: ${freq[num]}\nMoyenne attendue: ${avgFreq.toFixed(1)}\n√âcart: ${deviations[ctx.dataIndex] > 0 ? '+' : ''}${deviations[ctx.dataIndex].toFixed(1)}`;
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        grid: { color: 'rgba(255,255,255,0.05)' },
                        ticks: { color: '#9ca3af' },
                    },
                    x: { grid: { display: false }, ticks: { color: '#9ca3af', maxRotation: 90, font: { size: 10 } } }
                }
            }
        });
    }

    // ========== RETROANALYSE ==========
    let retroDone = false;

    function runRetroAnalysis() {
        if (retroDone) return;
        retroDone = true;

        const MIN_DRAWS = 30;
        const strategies = ['cold', 'frozen', 'combo', 'mix'];
        const stratLabels = {
            cold: '‚ùÑÔ∏è Froids (retards)',
            frozen: 'üßä Glac√©s (fr√©quence)',
            combo: 'üéØ Score combin√©',
            mix: 'üé≤ Mix √©quilibr√©'
        };

        const results = { cold: [], frozen: [], combo: [], mix: [] };

        // Incremental tracking
        const freq = {};
        for (let i = 1; i <= 49; i++) freq[i] = 0;
        const chFreq = {};
        for (let i = 1; i <= 10; i++) chFreq[i] = 0;
        const lastSeen = {};
        for (let i = 1; i <= 49; i++) lastSeen[i] = -1;
        const lastSeenCh = {};
        for (let i = 1; i <= 10; i++) lastSeenCh[i] = -1;

        for (let i = 0; i < allDraws.length; i++) {
            if (i >= MIN_DRAWS) {
                const n = i; // number of past draws available

                // Retards at this point
                const retards = {};
                for (let b = 1; b <= 49; b++) {
                    retards[b] = lastSeen[b] === -1 ? n : (i - 1 - lastSeen[b]);
                }
                const chRetards = {};
                for (let c = 1; c <= 10; c++) {
                    chRetards[c] = lastSeenCh[c] === -1 ? n : (i - 1 - lastSeenCh[c]);
                }

                const avgF = n * 5 / 49;
                const avgChF = n / 10;

                // --- COLD: highest retard ---
                const coldNums = Object.entries(retards)
                    .sort((a,b) => b[1]-a[1]).slice(0,5).map(e => parseInt(e[0]));
                const coldCh = parseInt(Object.entries(chRetards)
                    .sort((a,b) => b[1]-a[1])[0][0]);

                // --- FROZEN: lowest frequency ---
                const frozenNums = Object.entries(freq)
                    .filter(([,v]) => true) // all
                    .sort((a,b) => a[1]-b[1]).slice(0,5).map(e => parseInt(e[0]));
                const frozenCh = parseInt(Object.entries(chFreq)
                    .sort((a,b) => a[1]-b[1])[0][0]);

                // --- COMBO: score-based ---
                const scores = {};
                for (let b = 1; b <= 49; b++) {
                    scores[b] = retards[b] * 2 + Math.max(0, (avgF - freq[b]) * 3);
                }
                const comboNums = Object.entries(scores)
                    .sort((a,b) => b[1]-a[1]).slice(0,5).map(e => parseInt(e[0]));
                const comboCh = parseInt(Object.entries(chRetards).sort((a,b) => {
                    const dA = avgChF - chFreq[a[0]];
                    const dB = avgChF - chFreq[b[0]];
                    return (b[1]*2 + Math.max(0,dB*3)) - (a[1]*2 + Math.max(0,dA*3));
                })[0][0]);

                // --- MIX: deterministic version ---
                const sortedAll = Object.entries(freq)
                    .map(([k,v]) => ({num:parseInt(k), count:v}))
                    .sort((a,b) => a.count - b.count);
                const poolSize = Math.ceil(49 * 0.2); // 10
                const mixCold = sortedAll[0].num;
                const mixHot = sortedAll[sortedAll.length - 1].num;
                const middle = sortedAll.slice(poolSize, -poolSize);
                const tS = Math.ceil(middle.length / 3);
                const mixLow = middle[Math.floor(tS / 2)]?.num || sortedAll[poolSize].num;
                const mixMid = middle[tS + Math.floor(tS / 2)]?.num || sortedAll[24].num;
                const mixHigh = middle[Math.min(tS * 2 + Math.floor((middle.length - tS * 2) / 2), middle.length - 1)]?.num || sortedAll[38].num;
                let mixNums = [mixCold, mixLow, mixMid, mixHigh, mixHot];
                // Deduplicate if needed
                const mixSet = new Set(mixNums);
                if (mixSet.size < 5) {
                    // Fill from middle, avoiding duplicates
                    for (const m of middle) {
                        if (mixSet.size >= 5) break;
                        if (!mixSet.has(m.num)) { mixSet.add(m.num); mixNums = [...mixSet]; }
                    }
                    mixNums = [...mixSet];
                }
                const mixCh = parseInt(Object.entries(chFreq)
                    .map(([k,v]) => ({num:parseInt(k), diff:Math.abs(v - avgChF)}))
                    .sort((a,b) => a.diff - b.diff)[0].num);

                // Compare to actual draw i
                const actual = allDraws[i];
                const actualSet = new Set(actual.balls);
                const countM = (arr) => arr.filter(x => actualSet.has(x)).length;

                for (const [key, nums, ch] of [
                    ['cold', coldNums, coldCh],
                    ['frozen', frozenNums, frozenCh],
                    ['combo', comboNums, comboCh],
                    ['mix', mixNums, mixCh]
                ]) {
                    results[key].push({
                        drawIndex: i,
                        date: actual.date,
                        matches: countM(nums),
                        chanceMatch: actual.chance === ch ? 1 : 0,
                        suggested: [...nums].sort((a,b) => a-b),
                        suggestedChance: ch,
                        actual: actual.balls,
                        actualChance: actual.chance
                    });
                }
            }

            // Update incremental stats with draw i
            allDraws[i].balls.forEach(b => { freq[b]++; lastSeen[b] = i; });
            chFreq[allDraws[i].chance]++;
            lastSeenCh[allDraws[i].chance] = i;
        }

        // ===== RENDER RESULTS =====
        const totalAnalyzed = results.cold.length;
        const expectedBalls = 5 * 5 / 49; // ~0.5102
        const expectedChance = 1 / 10; // 0.1

        // Summary cards
        let summaryHTML = '';
        for (const s of strategies) {
            const avgMatch = results[s].reduce((a,r) => a + r.matches, 0) / totalAnalyzed;
            const chanceRate = results[s].reduce((a,r) => a + r.chanceMatch, 0) / totalAnalyzed * 100;
            const maxMatch = Math.max(...results[s].map(r => r.matches));
            const gt1 = results[s].filter(r => r.matches >= 2).length;
            const improvement = ((avgMatch / expectedBalls - 1) * 100).toFixed(1);
            summaryHTML += `
                <div class="stat-card">
                    <div class="value" style="font-size:1.5rem">${stratLabels[s]}</div>
                    <div class="value" style="color:${avgMatch > expectedBalls ? 'var(--green)' : 'var(--red)'}">${avgMatch.toFixed(3)}</div>
                    <div class="label">boules correctes en moy. (${improvement > 0 ? '+' : ''}${improvement}% vs hasard)</div>
                    <div style="margin-top:0.5rem;font-size:0.85rem;color:var(--muted)">
                        Chance: ${chanceRate.toFixed(1)}% | Max: ${maxMatch}/5 | ‚â•2 boules: ${gt1}√ó
                    </div>
                </div>`;
        }
        summaryHTML += `
            <div class="stat-card" style="border-color:var(--red)">
                <div class="value" style="font-size:1.5rem">üé≤ Hasard pur</div>
                <div class="value" style="color:var(--muted)">${expectedBalls.toFixed(3)}</div>
                <div class="label">boules correctes en moy. (r√©f√©rence)</div>
                <div style="margin-top:0.5rem;font-size:0.85rem;color:var(--muted)">
                    Chance: ${(expectedChance*100).toFixed(1)}% | ${totalAnalyzed} tirages analys√©s
                </div>
            </div>`;
        document.getElementById('retroSummary').innerHTML = summaryHTML;

        // Average matches bar chart
        const avgData = strategies.map(s =>
            results[s].reduce((a,r) => a + r.matches, 0) / totalAnalyzed
        );
        makeChart('chartRetroAvg', {
            type: 'bar',
            data: {
                labels: strategies.map(s => stratLabels[s]),
                datasets: [{
                    label: 'Moy. boules correctes',
                    data: avgData,
                    backgroundColor: ['#3b82f6', '#06b6d4', '#f59e0b', '#8b5cf6'],
                    borderRadius: 6
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: { display: false },
                    annotation: undefined
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        grid: { color: '#2a2d3a' },
                        ticks: { color: '#9ca3af' }
                    },
                    x: { ticks: { color: '#9ca3af', font: { size: 11 } } }
                }
            },
            plugins: [{
                id: 'baseline',
                afterDraw(chart) {
                    const yScale = chart.scales.y;
                    const ctx = chart.ctx;
                    const y = yScale.getPixelForValue(expectedBalls);
                    ctx.save();
                    ctx.strokeStyle = '#ef4444';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([6, 4]);
                    ctx.beginPath();
                    ctx.moveTo(chart.chartArea.left, y);
                    ctx.lineTo(chart.chartArea.right, y);
                    ctx.stroke();
                    ctx.fillStyle = '#ef4444';
                    ctx.font = '11px sans-serif';
                    ctx.fillText(`Hasard: ${expectedBalls.toFixed(2)}`, chart.chartArea.right - 90, y - 6);
                    ctx.restore();
                }
            }]
        });

        // Chance hit rate bar chart
        const chanceData = strategies.map(s =>
            results[s].reduce((a,r) => a + r.chanceMatch, 0) / totalAnalyzed * 100
        );
        makeChart('chartRetroChance', {
            type: 'bar',
            data: {
                labels: strategies.map(s => stratLabels[s]),
                datasets: [{
                    label: 'Taux de match Chance (%)',
                    data: chanceData,
                    backgroundColor: ['#3b82f6', '#06b6d4', '#f59e0b', '#8b5cf6'],
                    borderRadius: 6
                }]
            },
            options: {
                responsive: true,
                plugins: { legend: { display: false } },
                scales: {
                    y: {
                        beginAtZero: true,
                        grid: { color: '#2a2d3a' },
                        ticks: { color: '#9ca3af', callback: v => v + '%' }
                    },
                    x: { ticks: { color: '#9ca3af', font: { size: 11 } } }
                }
            },
            plugins: [{
                id: 'chanceBaseline',
                afterDraw(chart) {
                    const yScale = chart.scales.y;
                    const ctx = chart.ctx;
                    const y = yScale.getPixelForValue(10);
                    ctx.save();
                    ctx.strokeStyle = '#ef4444';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([6, 4]);
                    ctx.beginPath();
                    ctx.moveTo(chart.chartArea.left, y);
                    ctx.lineTo(chart.chartArea.right, y);
                    ctx.stroke();
                    ctx.fillStyle = '#ef4444';
                    ctx.font = '11px sans-serif';
                    ctx.fillText('Hasard: 10%', chart.chartArea.right - 80, y - 6);
                    ctx.restore();
                }
            }]
        });

        // Distribution chart (grouped bar)
        const distribData = strategies.map(s => {
            const counts = [0, 0, 0, 0, 0, 0]; // 0 to 5
            results[s].forEach(r => counts[r.matches]++);
            return counts;
        });
        const distribColors = ['#ef4444', '#f97316', '#eab308', '#22c55e', '#3b82f6', '#8b5cf6'];
        makeChart('chartRetroDistrib', {
            type: 'bar',
            data: {
                labels: strategies.map(s => stratLabels[s]),
                datasets: [0,1,2,3,4,5].map(m => ({
                    label: `${m} boule${m > 1 ? 's' : ''}`,
                    data: strategies.map((_, si) => distribData[si][m]),
                    backgroundColor: distribColors[m],
                    borderRadius: 3
                }))
            },
            options: {
                responsive: true,
                plugins: {
                    legend: { labels: { color: '#e4e4e7' } },
                    tooltip: {
                        callbacks: {
                            afterLabel: (ctx) => {
                                const pct = (ctx.raw / totalAnalyzed * 100).toFixed(1);
                                return `${pct}% des tirages`;
                            }
                        }
                    }
                },
                scales: {
                    y: { stacked: true, grid: { color: '#2a2d3a' }, ticks: { color: '#9ca3af' } },
                    x: { stacked: true, ticks: { color: '#9ca3af', font: { size: 11 } } }
                }
            }
        });

        // Evolution chart (moving average over 50 draws)
        const WINDOW = 50;
        const evoDatasets = [];
        const evoColors = ['#3b82f6', '#06b6d4', '#f59e0b', '#8b5cf6'];
        const evoLabels = [];

        for (let j = WINDOW - 1; j < totalAnalyzed; j++) {
            evoLabels.push(results.cold[j].date);
        }

        strategies.forEach((s, si) => {
            const movingAvg = [];
            for (let j = WINDOW - 1; j < totalAnalyzed; j++) {
                let sum = 0;
                for (let k = j - WINDOW + 1; k <= j; k++) sum += results[s][k].matches;
                movingAvg.push(sum / WINDOW);
            }
            evoDatasets.push({
                label: stratLabels[s],
                data: movingAvg,
                borderColor: evoColors[si],
                backgroundColor: 'transparent',
                borderWidth: 2,
                pointRadius: 0,
                tension: 0.3
            });
        });

        // Add baseline
        evoDatasets.push({
            label: 'Hasard pur',
            data: Array(evoLabels.length).fill(expectedBalls),
            borderColor: '#ef4444',
            borderDash: [6, 4],
            borderWidth: 2,
            pointRadius: 0,
            backgroundColor: 'transparent'
        });

        makeChart('chartRetroEvo', {
            type: 'line',
            data: { labels: evoLabels, datasets: evoDatasets },
            options: {
                responsive: true,
                plugins: { legend: { labels: { color: '#e4e4e7' } } },
                scales: {
                    y: {
                        grid: { color: '#2a2d3a' },
                        ticks: { color: '#9ca3af' },
                        title: { display: true, text: 'Moy. boules correctes (fen√™tre 50)', color: '#9ca3af' }
                    },
                    x: {
                        grid: { display: false },
                        ticks: { color: '#9ca3af', maxTicksLimit: 20, maxRotation: 45 }
                    }
                }
            }
        });

        // Best results table
        const bestEntries = [];
        for (const s of strategies) {
            results[s].forEach(r => {
                if (r.matches >= 2) {
                    bestEntries.push({ strategy: s, ...r });
                }
            });
        }
        bestEntries.sort((a,b) => (b.matches + b.chanceMatch) - (a.matches + a.chanceMatch) || b.matches - a.matches);

        let tableHTML = '<div style="max-height:500px;overflow-y:auto;border-radius:8px;border:1px solid var(--border)">';
        tableHTML += '<table class="retro-table"><thead><tr>';
        tableHTML += '<th>Date</th><th>Strat√©gie</th><th>Suggestion</th><th>Tirage r√©el</th><th>Boules ‚úì</th><th>Chance ‚úì</th>';
        tableHTML += '</tr></thead><tbody>';

        const shownEntries = bestEntries.slice(0, 100);
        for (const e of shownEntries) {
            const actualSet = new Set(e.actual);
            const sugBalls = e.suggested.map(n => {
                const hit = actualSet.has(n);
                return `<span class="retro-mini-ball ${hit ? 'hit' : 'miss'}">${n}</span>`;
            }).join('');
            const sugCh = `<span class="retro-mini-ball ${e.chanceMatch ? 'hit' : 'miss'}" style="${e.chanceMatch ? 'background:var(--chance);color:#000' : ''}">${e.suggestedChance}</span>`;

            const actBalls = e.actual.map(n => `<span class="retro-mini-ball" style="background:var(--accent);color:#fff">${n}</span>`).join('');
            const actCh = `<span class="retro-mini-ball" style="background:var(--chance);color:#000">${e.actualChance}</span>`;

            const badge = e.matches >= 4 ? 'amazing' : e.matches >= 3 ? 'great' : 'good';
            tableHTML += `<tr>
                <td>${e.date}</td>
                <td>${stratLabels[e.strategy]}</td>
                <td>${sugBalls} ${sugCh}</td>
                <td>${actBalls} ${actCh}</td>
                <td><span class="retro-badge ${badge}">${e.matches}/5</span></td>
                <td>${e.chanceMatch ? '<span class="retro-badge good">‚úì</span>' : '<span class="no-match">‚úó</span>'}</td>
            </tr>`;
        }
        if (bestEntries.length > 100) {
            tableHTML += `<tr><td colspan="6" style="color:var(--muted)">... et ${bestEntries.length - 100} autres r√©sultats</td></tr>`;
        }
        tableHTML += '</tbody></table></div>';
        tableHTML += `<p class="info-text" style="margin-top:0.5rem">${bestEntries.length} tirages avec ‚â•2 boules correctes sur ${totalAnalyzed} analys√©s (${(bestEntries.length/totalAnalyzed*100).toFixed(1)}%)</p>`;

        document.getElementById('retroBestTable').innerHTML = tableHTML;

        // Show results, hide loading
        document.getElementById('retroLoading').style.display = 'none';
        document.getElementById('retroResults').style.display = '';
        document.getElementById('retroChartsContainer').style.display = '';
    }

    </script>
</body>
</html>
